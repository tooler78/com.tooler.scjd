Marking:
	General Considerations (80 points)
	Documentation (50 points)
	Object-Oriented Design (50 points)
	GUI (70 points)
	Locking (80 points)
	Language Fluency (70 points)

---------------------------
1.	General
1.1	Architecture
1.2 Package Structure
1.3 Application startup
1.4 Shutdown hook
1.5 Exception handling	

2.	Documentation
2.1	User Guide
2.2	JavaDoc
2.3	choices.txt

3.	GUI
3.1	Configuration Dialogs
3.2	MVC pattern
3.3	Business Service
	
4.	Locking

5.	Network
5.1	RMI 
---------------------------
	
1.	General

As required, the DB interface has not been changed and is used exactly as was intended with the 
assignment. However, it has been reformatted and its JavaDoc information has been completed to make 
it easier to use and to be consistent with all other classes/interfaces produced in this application 
implementation.

In the delivered version of the implementation, all logging and testing code has been removed to 
make the code clearer and more concise. As a choice I decided that all issues/errors would be better
served to the user in a UI component (for example, an error message dialog). Although detailed 
logging can be very helpful when an issue occurs, a user may not be aware of the logging file 
without prior reading of a User Guide. This can lead to frustration with regard to "What am I doing 
wrong" scenario. 

1.2 Package Structure

The following package breakdown was used to organize classes of common functionality. These classes 
and interfaces within each package are related in terms of the set of tasks they perform.

suncertify.application	
	Provides the classes necessary for starting and handling shutdown of the application as well as 
	service provider classes for interaction with our data objects.
suncertify.db	
	Provides the DB interface and its local data file implementation along with all exception 
	classes.
suncertify.db.lock	
	Provides the classes for the application's locking mechanism. The locking functionality is 
	required to protect data interaction from multiple client access concurrently.
suncertify.domain	
	Provides the classes for the domain objects and database schema definition of the application.  
suncertify.remote	
	Provides classes to provide network connectivity between the client and the server using RMI.
suncertify.ui	
	Provides all centralized GUI classes required by the UI components of either client or server 
	launched application.
suncertify.ui.client	
	Provides all client specific GUI classes required for this application to operate as either a 
	networked client or a non-networked client.
suncertify.ui.server	
	Provides all server specific GUI classes required for this application to operate as a server 
	application.

1.3 Application startup

As required by the assignment, the application supports the following start options:

	java -jar <path_and_filename> [<mode>]
	Where the mode flag must be either 
		"server", indicating the server program must run
		"alone", indicating standalone mode
		or left out entirely, in which case the network client and GUI must run.

The class LaunchApplication, in the package suncertify.application, is the executable main class and 
therefore, where this program starts execution. It has access to the command arguments given to the 
program when it was executed and will be responsible for the high-level organization of the 
program's launch. I have used an enum class called LaunchMode (in the same package) to validate the 
currently supported launch parameters. This should allow a clear view to the reader of what is 
supported but also the ability to make updates for any future command line argument additions.

In the case of the user passing in an invalid parameter or the incorrect number of parameters on the
command line during execution, then the LaunchApplication will display usage text to the user and 
terminate. User will then need to retry executing startup of the application again.

Assuming the parameters entered pass the validation checks on startup then the LaunchApplication 
class will proceed to start in the correct launch mode (client, server or standalone). At this point
the user will be requested to enter some configuration information required to complete startup. The 
information required will differ based on the launch mode. For this validation I created an abstract 
class called UserEntryPanel in the suncertify.ui package. This class is extended by three sub 
classes to represent each of the the different launch modes currently supported. The abstract class 
contains common abstract methods that will be required by all panels such as "add components" and 
"validate user entry" for example. The reason I chose this type of approach is that it allows for 
easy extension should another required launch mode need to be added in the future with no disruption 
to existing classes. Also in the case of classes using a SubClass of the 
suncertify.ui.UserEntryPanel, it allows for loose coupling of the given panel where a change from  
one SubClass panel to another should not result in any change in the calling class's use of the 
panel, i.e. calling class can still call aGivenPanel.validate(). 

During the panel composition, the text fields requiring user entry, will have suggested values, 
which are read from a configuration file called suncertify.properties, as specified in the original 
assignment or where the file is not existing (on initial startup for example), default values will 
be presented where applicable. Property fetching and persisting back out to the given configuration 
file will be controlled by ApplicationProperties in the suncertify.application package. This class 
is a Singleton as I want to have one and only one class handling this task. Since I know that we 
will always need an instance , I used eager initialization, which always creates an instance.

Finally depending on the mode, a table representing the list of database records is displayed to the 
user (if launched in either client mode) or details on startup success failure is displays to the 
user. Both client and server will make use of the MVC pattern which i will detail in a later 
chapter.

1.4 Shutdown hook

One of the first tasks after during execution of the main class LaunchApplication, is to register a 
"Shutdown Hook". A shutdown hook is a class initialized and when the virtual machine begins its 
shutdown sequence it will start any registered shutdown hooks (not in any particular order) and 
let them run concurrently. My class GracefulShutdownHook is responsible for any tidy-up tasks that 
must be executed on the exit of the application. In the case of a "server" or "standalone" started 
application, then the data read up from the supported .db file now needs to be persisted back into 
the .db file (this is because of the choice i made with regard to my Data class implementation, but 
more on that in a later chapter). Also when the application mode is server then an attempt to unbind
the registered RMI service exposed for client-server communication, will also be attempted at this 
point. If for any reason that an error is experienced in RMI unbind task then the exception is 
caught and silently ignored - this is because the server is about to be shutdown.

However in the case of the task of persisting modified data records back out to the .db file, then 
we need to alert the user to the issue encountered as this is a serious error.

In the case of the networked client launch mode no tidy up task is required currently. However if it 
is required then this class should be updated in the future.

1.5 Exception handling	

The following are the checked exceptions currently handled in the Application:
	CommunicationException
		Instances of this exception class are thrown, if a client cannot invoke an operation on a 
		server object because of a network error (e.g. java.rmi.RemoteException).
	DuplicateKeyException (exception required as part of the OCMJD suncertify.db.DB interface)
		If a specified record already exists with the same key.
	DatabaseException
		Instances of this exception class are thrown, if the database does not conform to the 
		specified database schema.
	RecordAlreadyBookedException
		Instances of this exception class are thrown if during an attempt to book a record it fails 
		to succeed as it has already been booked.
	RecordNotFoundException (exception required as part of the OCMJD suncertify.db.DB interface)
		Instances of this exception class are thrown by {@code DB} methods if a specified record 
		does not exist or is marked as deleted in the database file.
	
As was mentioned in the General chapter text above, I have elected to try and report all error's 
encountered directly to the user via a GUI component (namely a JDialog). Taking into account the 
possible choice of reporting errors encountered with more detail into a log, i felt that, as a user I 
would appreciate being able to see the error message in the current application interface I am 
using.

2.	Documentation

The following chapters contain some small detail around the documentation, as required by the 
original assignment specification received.

2.1	User Guide

For the user guide i decided to have the following chapter layout:
	Starting the application
	Configuration
	Server mode
	Client and stand-alone mode
	GUI Overview
	Trouble-Shooting

The first two chapters deal with how to execute the startup of the application in the differing 
modes along with the different configuration parameters required. The following two chapters detail 
the different modes that the application will behave in post configuration validation. GUI Overview 
will detail the layout of the GUI now that it is launched along with more detail on the use cases 
supported from the GUI (as required from the original assignment). The final chapter is a utility 
chapter to help the user to quickly solve an issue reported by the GUI. The GUI messages displayed 
when encountering an error should be clear however my idea was for each of the error messages that 
are displayed through the GUI, a sub chapter in this section would help to explain totally what the 
issue is and how to resolve it. 

2.2	JavaDoc

As required in the original assignment, javadoc style comments are present for all elements of any 
public interface of each class. In the case where methods or variables are private, i have not used 
any javadoc comments. Instead I have tried to clearly name them in such a way as that it is clear 
what exactly each private method and/or variable are trying to represent. I chose this style of 
javadoc approach as I believe it to be a way of keeping the classes simple in their design and 
allows for good readability.

2.3	choices.txt

As required I have detailed, as best I can, what were the different decisions and design choices I 
made throughout the project, whether it be coding or documentation.

3.	GUI

3.1	Configuration Dialogs

Speak about the abstract dialog usage and extension for the different modes.

3.2	MVC pattern

How MVC is used on both client and server...speak how it is coded to interfaces so is loosely 
coupled in implementation.

3.3	Business Service

Speak about how the Business Service is on the client side as such...how he interacts with the 
DB interface and hides complexity behind simple methods which are use case driven.

